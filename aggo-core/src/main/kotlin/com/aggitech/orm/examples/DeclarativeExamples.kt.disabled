package com.aggitech.orm.examples

import com.aggitech.orm.config.DbConfig
import com.aggitech.orm.config.JdbcConnectionFactory
import com.aggitech.orm.dsl.*
import com.aggitech.orm.enums.SupportedDatabases
import kotlinx.coroutines.runBlocking

/**
 * Exemplos de uso da DSL declarativa do AggORM
 */

// Entities are now in ExampleEntities.kt to avoid redeclaration errors

// ==================== Exemplos de Uso ====================

fun mainDeclarative() = runBlocking {

    // Configuração da conexão
    val config = DbConfig(
        database = "myapp",
        host = "localhost",
        port = 5432,
        user = "postgres",
        password = "password",
        type = SupportedDatabases.POSTGRESQL
    )

    val connectionFactory = JdbcConnectionFactory(config)

    // ==================== SELECT Queries ====================

    // 1. Query básica com SELECT específico
    val users = query<User>(connectionFactory) {
        from(User::class)
        select {
            +User::name
            +User::email
            +User::age
        }
    }.execute()

    println("Users: $users")

    // 2. Query com SELECT ALL (sem especificar colunas)
    val allUsers = query<User>(connectionFactory) {
        from(User::class)
        select {
            all()
        }
    }.execute()

    // 3. Query com WHERE usando DSL tipada
    val adults = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::age gte 18
        }
    }.execute()

    // 4. Query com múltiplas condições WHERE
    val filtered = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::age gte 18
            User::email like "%@gmail.com"
        }
    }.execute()

    // 5. Query com WHERE usando operadores infix
    val specificUser = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::email eq "john@example.com"
        }
    }.executeFirst()

    // 6. Query com IN clause
    val usersInCities = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::cityId isIn listOf(1L, 2L, 3L)
        }
    }.execute()

    // 7. Query com ORDER BY
    val sortedUsers = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        orderBy {
            User::name.asc()
            User::age.desc()
        }
    }.execute()

    // 8. Query com LIMIT e OFFSET (paginação)
    val pagedUsers = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        orderBy {
            User::id.asc()
        }
        limit(10)
        offset(20)
    }.execute()

    // 9. Query com LEFT JOIN
    val usersWithCities = query<User>(connectionFactory) {
        from(User::class)
        select {
            +User::name
            +User::email
        }
        leftJoin {
            table(City::class)
            on(User::cityId, City::id)
        }
        where {
            City::country eq "Brazil"
        }
    }.execute()

    // 10. Query com INNER JOIN e múltiplas condições
    val userOrders = query<Order>(connectionFactory) {
        from(Order::class)
        select { all() }
        innerJoin {
            table(User::class)
            on(Order::userId, User::id)
        }
        where {
            User::age gt 21
            Order::status eq "pending"
        }
    }.execute()

    // 11. Query com DISTINCT
    val distinctEmails = query<User>(connectionFactory) {
        from(User::class)
        select {
            distinct()
            +User::email
        }
    }.execute()

    // 12. Query complexa com JOIN, WHERE, ORDER e LIMIT
    val complexQuery = query<User>(connectionFactory) {
        from(User::class)
        select {
            +User::name
            +User::email
            +User::age
        }
        leftJoin {
            table(City::class)
            on(User::cityId, City::id)
        }
        where {
            User::age gte 18
            City::country eq "Brazil"
            User::email like "%@gmail.com"
        }
        orderBy {
            User::name.asc()
        }
        limit(50)
    }.execute()

    // 13. Debug SQL gerado
    val sqlQuery = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::age gt 18
        }
    }
    println("SQL gerado: ${sqlQuery.toSql()}")

    // ==================== INSERT Operations ====================

    // 14. INSERT com valores explícitos usando DSL tipada
    val newUserId = insert<User>(connectionFactory) {
        into(User::class)
        set {
            User::name to "John Doe"
            User::email to "john@example.com"
            User::age to 30
        }
    }.execute()

    println("Novo usuário ID: $newUserId")

    // 15. INSERT usando uma entidade existente
    val newUser = User(
        name = "Jane Smith",
        email = "jane@example.com",
        age = 25,
        cityId = 1L
    )

    val userId = insert<User>(connectionFactory) {
        into(User::class)
        values(newUser)
    }.execute()

    // 16. INSERT de múltiplos registros usando transação
    transaction(connectionFactory) {
        insert<User>(connectionFactory) {
            into(User::class)
            set {
                User::name to "Alice"
                User::email to "alice@example.com"
                User::age to 28
            }
        }.execute()

        insert<User>(connectionFactory) {
            into(User::class)
            set {
                User::name to "Bob"
                User::email to "bob@example.com"
                User::age to 32
            }
        }.execute()
    }

    // ==================== UPDATE Operations ====================

    // 17. UPDATE usando DSL tipada
    val updatedRows = update<User>(connectionFactory) {
        table(User::class)
        set {
            User::email to "newemail@example.com"
            User::age to 31
        }
        where {
            User::id eq newUserId
        }
    }.execute()

    println("Linhas atualizadas: $updatedRows")

    // 18. UPDATE com múltiplas condições
    val bulkUpdate = update<User>(connectionFactory) {
        table(User::class)
        set {
            User::age to 18
        }
        where {
            User::age lt 18
            User::email like "%@example.com"
        }
    }.execute()

    // 19. UPDATE com condição IN
    val updateMultiple = update<Order>(connectionFactory) {
        table(Order::class)
        set {
            Order::status to "completed"
        }
        where {
            Order::id isIn listOf(1L, 2L, 3L)
        }
    }.execute()

    // ==================== DELETE Operations ====================

    // 20. DELETE usando DSL tipada
    val deletedRows = delete<User>(connectionFactory) {
        from(User::class)
        where {
            User::id eq newUserId
        }
    }.execute()

    println("Linhas deletadas: $deletedRows")

    // 21. DELETE com múltiplas condições
    val bulkDelete = delete<User>(connectionFactory) {
        from(User::class)
        where {
            User::age lt 18
            User::email.isNull()
        }
    }.execute()

    // 22. DELETE condicional
    val conditionalDelete = delete<Order>(connectionFactory) {
        from(Order::class)
        where {
            Order::status eq "cancelled"
            Order::amount lt 10.0
        }
    }.execute()

    // ==================== Transações Complexas ====================

    // 23. Transação com rollback automático em caso de erro
    try {
        transaction(connectionFactory) {
            // Insert user
            val userId = insert<User>(connectionFactory) {
                into(User::class)
                set {
                    User::name to "Transaction Test"
                    User::email to "transaction@test.com"
                    User::age to 25
                }
            }.execute()

            // Insert order para o usuário
            insert<Order>(connectionFactory) {
                into(Order::class)
                set {
                    Order::userId to userId
                    Order::product to "Product A"
                    Order::amount to 99.99
                    Order::status to "pending"
                }
            }.execute()

            // Se alguma operação falhar, todas são revertidas
            println("Transação completada com sucesso")
        }
    } catch (e: Exception) {
        println("Transação falhou: ${e.message}")
    }

    // ==================== Queries Avançadas ====================

    // 24. Query com NULL check
    val usersWithoutCity = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::cityId.isNull()
        }
    }.execute()

    // 25. Query com NOT NULL check
    val usersWithCity = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::cityId.isNotNull()
        }
    }.execute()

    // 26. Query com raw SQL para casos especiais
    val customQuery = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            raw("age BETWEEN ? AND ?", 18, 65)
        }
    }.execute()

    // 27. Subquery simulada com condições complexas
    val premiumUsers = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::age gte 25
            User::email like "%@company.com"
        }
        orderBy {
            User::age.desc()
        }
        limit(100)
    }.execute()
}

// ==================== Repository Pattern com DSL Declarativa ====================

class UserRepositoryDSL(private val connectionFactory: JdbcConnectionFactory) {

    suspend fun findAll(): List<User> = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
    }.execute()

    suspend fun findById(id: Long): User? = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::id eq id
        }
    }.executeFirst()

    suspend fun findByEmail(email: String): User? = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::email eq email
        }
    }.executeFirst()

    suspend fun findAdults(): List<User> = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::age gte 18
        }
        orderBy {
            User::name.asc()
        }
    }.execute()

    suspend fun findByAgeRange(minAge: Int, maxAge: Int): List<User> = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::age gte minAge
            User::age lte maxAge
        }
    }.execute()

    suspend fun findByCityIds(cityIds: List<Long>): List<User> = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            User::cityId isIn cityIds
        }
    }.execute()

    suspend fun create(user: User): Long = insert<User>(connectionFactory) {
        into(User::class)
        values(user)
    }.execute()

    suspend fun update(id: Long, name: String, email: String): Int = update<User>(connectionFactory) {
        table(User::class)
        set {
            User::name to name
            User::email to email
        }
        where {
            User::id eq id
        }
    }.execute()

    suspend fun delete(id: Long): Int = delete<User>(connectionFactory) {
        from(User::class)
        where {
            User::id eq id
        }
    }.execute()

    suspend fun searchByNameAndEmail(searchTerm: String): List<User> = query<User>(connectionFactory) {
        from(User::class)
        select { all() }
        where {
            raw("(name LIKE ? OR email LIKE ?)", "%$searchTerm%", "%$searchTerm%")
        }
    }.execute()
}

// ==================== Service Layer Exemplo ====================

class OrderServiceDSL(
    private val connectionFactory: JdbcConnectionFactory
) {

    suspend fun createOrderForUser(userId: Long, product: String, amount: Double): Long {
        return transaction(connectionFactory) {
            // Verifica se usuário existe
            val user = query<User>(connectionFactory) {
                from(User::class)
                select { all() }
                where {
                    User::id eq userId
                }
            }.executeFirst() ?: throw IllegalArgumentException("User not found")

            // Cria o pedido
            insert<Order>(connectionFactory) {
                into(Order::class)
                set {
                    Order::userId to userId
                    Order::product to product
                    Order::amount to amount
                    Order::status to "pending"
                }
            }.execute()
        }
    }

    suspend fun getPendingOrdersByUser(userId: Long): List<Order> = query<Order>(connectionFactory) {
        from(Order::class)
        select { all() }
        where {
            Order::userId eq userId
            Order::status eq "pending"
        }
        orderBy {
            Order::id.desc()
        }
    }.execute()

    suspend fun completeOrder(orderId: Long): Boolean {
        val rows = update<Order>(connectionFactory) {
            table(Order::class)
            set {
                Order::status to "completed"
            }
            where {
                Order::id eq orderId
                Order::status eq "pending"
            }
        }.execute()

        return rows > 0
    }
}
